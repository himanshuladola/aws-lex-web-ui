{"version":3,"sources":["webpack:///webpack/bootstrap dbc524dee7130b545115","webpack:///./src/lib/lex/wav-worker.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,KAAK;QACL;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;QAEA;QACA;;;;;;;AC7DA;AACA;;AAEA;AACA;AACA,4CAA4C,8BAA8B;AAC1E,wCAAwC,iBAAiB;AACzD,2CAA2C,qBAAqB;AAChE;AACA,mCAAmC,oDAAoD;AACvF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,0CAA0C,OAAO;;AAEjD;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA,oBAAoB,sCAAsC;AAC1D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wCAAwC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle/wav-worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap dbc524dee7130b545115","// based on https://github.com/mattdiamond/Recorderjs/blob/master/src/recorder.js\r\n// with a few optimizations including downsampling and trimming quiet samples\r\n\r\n/* global Blob self */\r\n/* eslint no-restricted-globals: off */\r\n/* eslint prefer-arrow-callback: [\"error\", { \"allowNamedFunctions\": true }] */\r\n/* eslint no-param-reassign: [\"error\", { \"props\": false }] */\r\n/* eslint no-use-before-define: [\"error\", { \"functions\": false }] */\r\n/* eslint no-plusplus: off */\r\n/* eslint comma-dangle: [\"error\", {\"functions\": \"never\", \"objects\": \"always-multiline\"}] */\r\n/* eslint-disable prefer-destructuring */\r\nconst bitDepth = 16;\r\nconst bytesPerSample = bitDepth / 8;\r\nconst outSampleRate = 16000;\r\nconst outNumChannels = 1;\r\n\r\nlet recLength = 0;\r\nlet recBuffers = [];\r\n\r\nconst options = {\r\n  sampleRate: 44000,\r\n  numChannels: 1,\r\n  useDownsample: true,\r\n  // controls if the encoder will trim silent samples at begining and end of buffer\r\n  useTrim: true,\r\n  // trim samples below this value at the beginnig and end of the buffer\r\n  // lower the value trim less silence (larger file size)\r\n  // reasonable values seem to be between 0.005 and 0.0005\r\n  quietTrimThreshold: 0.0008,\r\n  // how many samples to add back to the buffer before/after the quiet threshold\r\n  // higher values result in less silence trimming (larger file size)\r\n  // reasonable values seem to be between 3500 and 5000\r\n  quietTrimSlackBack: 4000,\r\n};\r\n\r\nself.onmessage = (evt) => {\r\n  switch (evt.data.command) {\r\n    case 'init':\r\n      init(evt.data.config);\r\n      break;\r\n    case 'record':\r\n      record(evt.data.buffer);\r\n      break;\r\n    case 'exportWav':\r\n      exportWAV(evt.data.type);\r\n      break;\r\n    case 'getBuffer':\r\n      getBuffer();\r\n      break;\r\n    case 'clear':\r\n      clear();\r\n      break;\r\n    case 'close':\r\n      self.close();\r\n      break;\r\n    default:\r\n      break;\r\n  }\r\n};\r\n\r\nfunction init(config) {\r\n  Object.assign(options, config);\r\n  initBuffers();\r\n}\r\n\r\nfunction record(inputBuffer) {\r\n  for (let channel = 0; channel < options.numChannels; channel++) {\r\n    recBuffers[channel].push(inputBuffer[channel]);\r\n  }\r\n  recLength += inputBuffer[0].length;\r\n}\r\n\r\nfunction exportWAV(type) {\r\n  const buffers = [];\r\n  for (let channel = 0; channel < options.numChannels; channel++) {\r\n    buffers.push(mergeBuffers(recBuffers[channel], recLength));\r\n  }\r\n  let interleaved;\r\n  if (options.numChannels === 2 && outNumChannels === 2) {\r\n    interleaved = interleave(buffers[0], buffers[1]);\r\n  } else {\r\n    interleaved = buffers[0];\r\n  }\r\n  const downsampledBuffer = downsampleTrimBuffer(interleaved, outSampleRate);\r\n  const dataview = encodeWAV(downsampledBuffer);\r\n  const audioBlob = new Blob([dataview], { type });\r\n\r\n  self.postMessage({\r\n    command: 'exportWAV',\r\n    data: audioBlob,\r\n  });\r\n}\r\n\r\nfunction getBuffer() {\r\n  const buffers = [];\r\n  for (let channel = 0; channel < options.numChannels; channel++) {\r\n    buffers.push(mergeBuffers(recBuffers[channel], recLength));\r\n  }\r\n  self.postMessage({ command: 'getBuffer', data: buffers });\r\n}\r\n\r\nfunction clear() {\r\n  recLength = 0;\r\n  recBuffers = [];\r\n  initBuffers();\r\n}\r\n\r\nfunction initBuffers() {\r\n  for (let channel = 0; channel < options.numChannels; channel++) {\r\n    recBuffers[channel] = [];\r\n  }\r\n}\r\n\r\nfunction mergeBuffers(recBuffer, length) {\r\n  const result = new Float32Array(length);\r\n  let offset = 0;\r\n  for (let i = 0; i < recBuffer.length; i++) {\r\n    result.set(recBuffer[i], offset);\r\n    offset += recBuffer[i].length;\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction interleave(inputL, inputR) {\r\n  const length = inputL.length + inputR.length;\r\n  const result = new Float32Array(length);\r\n\r\n  let index = 0;\r\n  let inputIndex = 0;\r\n\r\n  while (index < length) {\r\n    result[index++] = inputL[inputIndex];\r\n    result[index++] = inputR[inputIndex];\r\n    inputIndex++;\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction floatTo16BitPCM(output, offset, input) {\r\n  for (let i = 0, o = offset; i < input.length; i++, o += 2) {\r\n    const s = Math.max(-1, Math.min(1, input[i]));\r\n    output.setInt16(o, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\r\n  }\r\n}\r\n\r\n// Lex doesn't require proper wav header\r\n// still inserting wav header for playing on client side\r\nfunction addHeader(view, length) {\r\n  // RIFF identifier 'RIFF'\r\n  view.setUint32(0, 1380533830, false);\r\n  // file length minus RIFF identifier length and file description length\r\n  view.setUint32(4, 36 + length, true);\r\n  // RIFF type 'WAVE'\r\n  view.setUint32(8, 1463899717, false);\r\n  // format chunk identifier 'fmt '\r\n  view.setUint32(12, 1718449184, false);\r\n  // format chunk length\r\n  view.setUint32(16, 16, true);\r\n  // sample format (raw)\r\n  view.setUint16(20, 1, true);\r\n  // channel count\r\n  view.setUint16(22, outNumChannels, true);\r\n  // sample rate\r\n  view.setUint32(24, outSampleRate, true);\r\n  // byte rate (sample rate * block align)\r\n  view.setUint32(28, outSampleRate * bytesPerSample * outNumChannels, true);\r\n  // block align (channel count * bytes per sample)\r\n  view.setUint16(32, bytesPerSample * outNumChannels, true);\r\n  // bits per sample\r\n  view.setUint16(34, bitDepth, true);\r\n  // data chunk identifier 'data'\r\n  view.setUint32(36, 1684108385, false);\r\n}\r\n\r\nfunction encodeWAV(samples) {\r\n  const buffer = new ArrayBuffer(44 + (samples.length * 2));\r\n  const view = new DataView(buffer);\r\n\r\n  addHeader(view, samples.length);\r\n  floatTo16BitPCM(view, 44, samples);\r\n\r\n  return view;\r\n}\r\n\r\nfunction downsampleTrimBuffer(buffer, rate) {\r\n  if (rate === options.sampleRate) {\r\n    return buffer;\r\n  }\r\n\r\n  const length = buffer.length;\r\n  const sampleRateRatio = options.sampleRate / rate;\r\n  const newLength = Math.round(length / sampleRateRatio);\r\n\r\n  const result = new Float32Array(newLength);\r\n  let offsetResult = 0;\r\n  let offsetBuffer = 0;\r\n  let firstNonQuiet = 0;\r\n  let lastNonQuiet = length;\r\n  while (offsetResult < result.length) {\r\n    const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\r\n    let accum = 0;\r\n    let count = 0;\r\n    for (let i = offsetBuffer; (i < nextOffsetBuffer) && (i < length); i++) {\r\n      accum += buffer[i];\r\n      count++;\r\n    }\r\n    // mark first and last sample over the quiet threshold\r\n    if (accum > options.quietTrimThreshold) {\r\n      if (firstNonQuiet === 0) {\r\n        firstNonQuiet = offsetResult;\r\n      }\r\n      lastNonQuiet = offsetResult;\r\n    }\r\n    result[offsetResult] = accum / count;\r\n    offsetResult++;\r\n    offsetBuffer = nextOffsetBuffer;\r\n  }\r\n\r\n  /*\r\n  console.info('encoder trim size reduction',\r\n    (Math.min(newLength, lastNonQuiet + options.quietTrimSlackBack) -\r\n    Math.max(0, firstNonQuiet - options.quietTrimSlackBack)) / result.length\r\n  );\r\n  */\r\n  return (options.useTrim) ?\r\n    // slice based on quiet threshold and put slack back into the buffer\r\n    result.slice(\r\n      Math.max(0, firstNonQuiet - options.quietTrimSlackBack),\r\n      Math.min(newLength, lastNonQuiet + options.quietTrimSlackBack)\r\n    ) :\r\n    result;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/eslint-loader?{}!./src/lib/lex/wav-worker.js\n// module id = 0\n// module chunks = 0"],"sourceRoot":""}